<style>
    ol {
        margin-top: 0;
    }

    #input:focus, button:focus, input:focus, select:focus {
        outline: none;
    }

    
    .hidden {
        display: none;
    }

    button {
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        padding: 3px 8px;
        cursor: pointer;
        font-size: 14px;
        margin: 10px 0;
    }

    .dropdown {
        position: relative;
        display: inline-block;
        font-size: 12px;
    }

    /* Dropdown content */
    .dropdown-content {
        display: none;
        position: absolute;
        background-color: white;
        min-width: 200px;
        max-height: 150px;
        margin-top: -10px;
        overflow-y: auto;
        border: 1px solid #ccc;
        z-index: 1;
        padding: 5px;
    }

    /* Show dropdown on button click */
    .dropdown.show .dropdown-content {
        display: block;
        user-select: none;
    }

    /* Style checkboxes */
    .dropdown-content input[type="checkbox"] {
        margin-right: 4px;
        transform: scale(0.85);
    }

    .back-to-main {
        position: fixed;
        top: 3px;
        right: 10px;
    }
</style>
<head>
    <meta property="og:title" content="ngimëte Similarities">
    <meta property="og:description" content="Find homophones and minimal pairs">
    <meta property="og:url" content="https://rus1130.github.io/projects/ngimete/similarities">
</head>
<body>
    <div class="back-to-main">
        <button onclick="location.href='index.html'" style="padding: 4px;">Back to main page</button>
    </div>
    <div id="chosen-settings" class="hidden"></div>
    <div id="loading" class="hidden"></div>
    <div id="dropdown-wrapper" style="display: inline-block; margin-bottom: -10px;">

        <label for="dialect-select">A'atsilwi dialect:</label>
        <input type="checkbox" id="dialect-select">

        <label for="minimal-pair-distance" title="Maximum number of differing letters between two words to be considered a minimal pair.">Max Minimal Pair Distance:</label>
        <input type="range" id="minimal-pair-distance" min="0" max="8" value="0" title="Maximum number of differing letters between two words to be considered a minimal pair.">
        <span id="minimal-pair-distance-value" title="Maximum number of differing letters between two words to be considered a minimal pair.">0</span>
        <br id="REMOVE-ME">

        <label for="exclude-categories-dropdown">Include Categories:</label>
        <div id="exclude-categories-dropdown" class="dropdown">
            <button type="button" class="dropbtn" id="exclude-categories-button">Select Categories ▼</button>
            <div class="dropdown-content" id="exclude-categories">
            </div>
        </div><br>

        <label for="homophone-type" title="yeeessss I KNOWWW homophone is technically always 'phonetic' SCREW YOU!!!!!">Homophone Type:</label>
        <select id="homophone-type" title="yeeessss I KNOWWW homophone is technically always 'phonetic' SCREW YOU!!!!!" style="margin-bottom: 10px;">
            <option value="orthographic" selected>Orthographic</option>
            <option value="phonetic">Phonetic</option>
        </select><br>

        <label for="minimal-pair-type">Minimal Pair Type:</label>
        <select id="minimal-pair-type" style="margin-bottom: 10px;">
            <option value="orthographic" selected>Orthographic</option>
            <option value="phonetic">Phonetic</option>
        </select><br>
        <label for="minimal-pair-differ-type">Minimal pair single vowel difference only:</label>
        <input type="checkbox" id="minimal-pair-differ-type">
        <span>(táne - tane matches; tane - tine and tane - tame do not)</span>
        <br><br>
    </div>
    <br>
    <button id="begin" style="margin-bottom: -20px;">Begin</button>
    <h1 id="homophone-heading" class="hidden">Homophones:</h1>
    <div id="homophone-results"></div>
    <h1 id="minimal-pair-heading" class="hidden">Minimal Pairs:</h1>
    <div id="minimal-pair-results"></div>
</body>
<script type="module" defer>
    import { dict } from './dictionary.js';


    const chunkSize = 350;

    const loadingDiv = document.getElementById("loading");
    const homophoneResults = document.getElementById("homophone-results");
    const minimalPairResults = document.getElementById("minimal-pair-results");
    const beginButton = document.getElementById("begin");
    const dropdownWrapper = document.getElementById("dropdown-wrapper");

    const dialectSelect = document.getElementById("dialect-select");

    const minimalPairDistanceInput = document.getElementById("minimal-pair-distance");
    const minimalPairDistanceValue = document.getElementById("minimal-pair-distance-value");

    const minimalPairTypeSelect = document.getElementById("minimal-pair-type");
    const homophoneTypeSelect = document.getElementById("homophone-type");

    const homophoneHeading = document.getElementById("homophone-heading");
    const minimalPairHeading = document.getElementById("minimal-pair-heading");

    minimalPairDistanceInput.addEventListener("input", () => {
        minimalPairDistanceValue.textContent = minimalPairDistanceInput.value;
    });

    const minimalPairDifferTypeCheckbox = document.getElementById("minimal-pair-differ-type");

    // Keep track of rendered divs by key
    const homophoneDivs = new Map();
    const minimalPairDivs = new Map();

    const longVowelFixes = {
        "aː": "A",
        "eː": "E",
        "iː": "I",
        "oː": "O",
        "uː": "U",
        "ɑː": "Q",
    }

    const longVowelOrthoFixes = {
        "á": "A",
        "é": "E",
        "í": "I",
        "ó": "O",
        "ú": "U",
        "är": "Q",
    }

    const longToShort = {
        "A": "a",
        "E": "e",
        "I": "i",
        "O": "o",
        "U": "u",
        "Q": "ä",
    }

    function isHomophone(word1, word2, dialect, type){
        if(type == "orthographic") return word1.value[dialect] === word2.value[dialect];
        else if(type == "phonetic") {
            let w1 = word1.script[dialect].ipa.join("");
            let w2 = word2.script[dialect].ipa.join("");

            // Normalize long vowels for homophone check
            for(const [longVowel, replacement] of Object.entries(longVowelFixes)){
                w1 = w1.replaceAll(longVowel, replacement);
                w2 = w2.replaceAll(longVowel, replacement);
            }

            return w1 === w2;
        }
        else throw new Error("Invalid type for isHomophone");
    }

    /**
     * Checks if two words are homophones in the specified dialect and type.
     * @param {Object} word1 - The first word object.
     * @param {Object} word2 - The second word object.
     * @param {string} dialect - The dialect to check ('A'atsilwi' or 'Standard').
     * @param {string} type - The type of homophone check ('orthographic' or 'phonetic').
     * @param {boolean} singleVowelDifference - Only match if a single vowel difference exists (tane - táne matches; tane - tine and tane - tame do not)
     */
    function isNearHomophone(word1, word2, dialect, type, singleVowelDifference = false){
        let val1;
        let val2;

        if(type == "orthographic") {
            val1 = word1.value[dialect];
            val2 = word2.value[dialect];
        } else if(type == "phonetic") {
            val1 = word1.script[dialect].ipa.join("");
            val2 = word2.script[dialect].ipa.join("");

            // Replace long vowels with single-character representations for comparison
            for(const [longVowel, replacement] of Object.entries(longVowelFixes)){
                val1 = val1.replaceAll(longVowel, replacement);
                val2 = val2.replaceAll(longVowel, replacement);
            }

        } else {
            throw new Error("Invalid type for isNearHomophone");
        }

        if (singleVowelDifference) {
            if (val1 === val2) return false;
            if (val1.length !== val2.length) return false;


            for(const [longVowel, replacement] of Object.entries(longVowelOrthoFixes)){
                val1 = val1.replaceAll(longVowel, replacement);
                val2 = val2.replaceAll(longVowel, replacement);
            }

            let differences = 0;

            for (let i = 0; i < val1.length; i++) {
                if (val1[i] !== val2[i]) {
                    differences++;
                    if (differences > 1) return false;

                    const a = val1[i];
                    const b = val2[i];

                    const isSameVowelLengthDiff =
                        (longToShort[a] === b) ||
                        (longToShort[b] === a);

                    if (!isSameVowelLengthDiff) {
                        return false;
                    }
                }
            }

            return differences === 1;
        }

        if(Math.abs(val1.length - val2.length) > parseInt(minimalPairDistanceInput.value)){
            return false;
        }

        if(val1 == val2){
            return false;
        }

        let differences = 0;
        let i = 0;
        let j = 0;

        while(i < val1.length && j < val2.length){
            if(val1[i] !== val2[j]){
                differences++;
                if(differences > 1){
                    return false;
                }

                if(val1.length > val2.length){
                    i++;
                } else if(val1.length < val2.length){
                    j++;
                } else {
                    i++;
                    j++;
                }
            } else {
                i++;
                j++;
            }
        }

        return true;
    }

    function getDialect(){
        return dialectSelect.checked ? "A'atsilwi" : "Standard";
    }

    function addOrUpdateHomophoneSet(key, set){
        // Check if div already exists
        if(homophoneDivs.has(key)){
            // Update existing div
            const div = homophoneDivs.get(key);
            const ol = div.querySelector("ol");
            
            // Clear and repopulate the list
            ol.innerHTML = "";
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });
        } else {
            // Create new div
            const div = document.createElement("div");

            const keySpan = document.createElement("span");
            keySpan.style.fontWeight = "bold";
            keySpan.textContent = key;
            div.appendChild(keySpan);

            const ol = document.createElement("ol");
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });

            div.appendChild(ol);
            homophoneResults.appendChild(div);
            
            // Store reference to the div
            homophoneDivs.set(key, div);
        }
    }

    function addOrUpdateMinimalPairSet(key, set){
        // Check if div already exists
        if(minimalPairDivs.has(key)){
            // Update existing div
            const div = minimalPairDivs.get(key);
            const ol = div.querySelector("ol");
            
            // Clear and repopulate the list
            ol.innerHTML = "";
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });
        } else {
            // Create new div
            const div = document.createElement("div");

            const keySpan = document.createElement("span");
            keySpan.style.fontWeight = "bold";
            keySpan.textContent = key;
            div.appendChild(keySpan);

            const ol = document.createElement("ol");
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });

            div.appendChild(ol);
            minimalPairResults.appendChild(div);
            
            // Store reference to the div
            minimalPairDivs.set(key, div);
        }
    }

    async function findPairs(words) {
        const homophones = new Map();
        const nearHomophones = new Map();

        const resultsContainer = document.getElementById("results");

        const totalComparisons = (words.length * (words.length - 1)) / 2;
        let comparisonsDone = 0;

        const dialect = getDialect();

        for (let i = 0; i < words.length; i++) {
            for (let j = i + 1; j < words.length; j++) {

                const w1 = words[i];
                const w2 = words[j];

                const homophoneType = homophoneTypeSelect.value;
                const minimalPairType = minimalPairTypeSelect.value;

                // --- HOMOPHONE CHECK ---
                if (isHomophone(w1, w2, dialect, homophoneType)) {
                    let key = [...new Set([w1.value[dialect], w2.value[dialect]])].join(", ");

                    if(homophoneType == "phonetic"){
                        key += ` - ${w1.script[dialect].ipa.join("")}`;
                    }

                    if (key.trim() !== "" && w2.value[dialect].trim() !== "") {
                        if (!homophones.has(key)) homophones.set(key, new Set());
                        homophones.get(key).add(w1.key);
                        homophones.get(key).add(w2.key);

                        addOrUpdateHomophoneSet(key, homophones.get(key));
                    }
                }

                // --- NEAR HOMOPHONE (MINIMAL PAIR) CHECK ---
                if (isNearHomophone(w1, w2, dialect, minimalPairType, minimalPairDifferTypeCheckbox.checked)) {
                    let key = `${w1.value[dialect]} ~ ${w2.value[dialect]}`
                    
                    if(minimalPairType == "phonetic"){
                        key += `; ${w1.script[dialect].ipa.join("")} ~ ${w2.script[dialect].ipa.join("")}`;
                    }

                    if (w1.value[dialect].trim() !== "" && w2.value[dialect].trim() !== "") {
                        if (!nearHomophones.has(key)) nearHomophones.set(key, new Set());
                        nearHomophones.get(key).add(w1.key);
                        nearHomophones.get(key).add(w2.key);

                        addOrUpdateMinimalPairSet(key, nearHomophones.get(key));
                    }
                }

                comparisonsDone++;

                // --- YIELD EVERY N COMPARISONS TO PREVENT DOM FREEZING ---
                if (comparisonsDone % chunkSize === 0) {
                    loadingDiv.textContent =
                        `Progress: ${((comparisonsDone / totalComparisons) * 100).toFixed(2)}%`;

                    // Actually yield to the browser event loop
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
        }

        const l = (n) => n.toLocaleString();

        loadingDiv.innerHTML =
            `Complete! Found <b>${l(homophones.size)}</b> homophone set${homophones.size === 1 ? "" : "s"} and <b>${l(nearHomophones.size)}</b> minimal pair${nearHomophones.size === 1 ? "" : "s"} in <b>${l(words.length)}</b> word${words.length === 1 ? "" : "s"}. Total comparisons: <b>${l(totalComparisons)}</b>. Reload the page to run again.`;
    }

    dict.waitForDictLoad().then(async () => {
        async function generateCategoryCheckboxes() {
            const container = document.getElementById("exclude-categories");
            container.innerHTML = "";

            const categories = dict.practiceOrder

            categories.forEach(category => {
                if(!defaultExcludedCategories.includes(category)) {
                    const id = `exclude-${category.replace(/\s+/g, "-")}`;

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.name = "exclude-category";
                    checkbox.value = category;
                    checkbox.id = id;
                    checkbox.checked = true;

                    const label = document.createElement("label");
                    label.htmlFor = id;
                    label.textContent = category;

                    const wrapper = document.createElement("div");
                    wrapper.appendChild(checkbox);
                    wrapper.appendChild(label);

                    container.appendChild(wrapper);

                    // Shift+Click behavior: check all other checkboxes
                    checkbox.addEventListener("click", (e) => {
                        // get how many checkboxes are checked
                        updateCheckedBoxText();

                        if (e.shiftKey) {
                            const allCheckboxes = container.querySelectorAll('input[name="exclude-category"]');
                            allCheckboxes.forEach(cb => {
                                if (cb !== checkbox) cb.checked = false;
                            });
                            e.target.checked = true;
                            updateCheckedBoxText();
                        }
                    });
                }
            });
        }

        function updateCheckedBoxText(){
            const container = document.getElementById("exclude-categories");
            const checkedBoxes = container.querySelectorAll('input[name="exclude-category"]:checked').length;

            if(checkedBoxes === 0) excludeCategoriesButton.innerText = "Select Categories ▼";
            else excludeCategoriesButton.innerText = `${checkedBoxes} Categor${checkedBoxes == 1 ? "y" : "ies"} Included ▼`;
        }

        function getIncludedCategories() {
            const categories = [];

            // Included categories from nav checkboxes
            const checkedBoxes = document.querySelectorAll('input[name="exclude-category"]:checked');
            checkedBoxes.forEach(cb => categories.push(cb.value));

            return categories;
        }

        
        const dropdown = document.getElementById("exclude-categories-button");

        const excludeCategoriesButton = document.getElementById("exclude-categories-button");
        const defaultExcludedCategories = ["Consonant Sounds", "Vowel Sounds", "Connecting Letters", "Tenses", "Phrases", "Grammar"];

        const container = document.getElementById("exclude-categories-dropdown");

        await generateCategoryCheckboxes();
        updateCheckedBoxText();

        if(localStorage.getItem("ngimete-similarities-settings")){
            const settings = JSON.parse(localStorage.getItem("ngimete-similarities-settings"));

            document.getElementById("dialect-select").checked = settings.dialect === "A'atsilwi";
            document.getElementById("minimal-pair-distance").value = settings.maxMinimalPairDistance;
            document.getElementById("minimal-pair-distance-value").textContent = settings.maxMinimalPairDistance;
            document.getElementById("homophone-type").value = settings.homophoneType;
            document.getElementById("minimal-pair-type").value = settings.minimalPairType;
            document.getElementById("minimal-pair-differ-type").checked = settings.minimalPairDifferType;

            // Set included categories
            const checkboxes = document.querySelectorAll('input[name="exclude-category"]');
            checkboxes.forEach(cb => {
                cb.checked = settings.includedCategories.includes(cb.value);
            });
            updateCheckedBoxText();
        }

        dropdown.addEventListener("click", () => {
            container.classList.toggle("show");
        });

        window.addEventListener("click", (e) => {
            if (!container.contains(e.target)) {
                container.classList.remove("show");
            }
        });


        beginButton.addEventListener("click", async () => {
            beginButton.remove();
            loadingDiv.classList.remove("hidden");
            document.getElementById("REMOVE-ME").remove();

             // get the included categories
            const includedCategories = structuredClone(getIncludedCategories());

            // get all available categories (excluding defaults)
            const allAvailableCategories = dict.practiceOrder.filter(cat => !defaultExcludedCategories.includes(cat));
            
            // get the excluded categories
            const excludedCategories = allAvailableCategories.filter(cat => !includedCategories.includes(cat));

            document.getElementById("chosen-settings").innerHTML =
                `<b>Dialect:</b> ${getDialect()}<br>
                 <b>Max Minimal Pair Distance:</b> ${minimalPairDistanceInput.value}<br>
                 <b>Homophone Type:</b> ${homophoneTypeSelect.value}<br>
                 <b>Minimal Pair Type:</b> ${minimalPairTypeSelect.value}<br>
                 <b>Excluded Categories:</b> ${excludedCategories.length > 0 ? excludedCategories.join(", ") : "None"}`;


            localStorage.setItem("ngimete-similarities-settings", JSON.stringify({
                dialect: getDialect(),
                maxMinimalPairDistance: minimalPairDistanceInput.value,
                homophoneType: homophoneTypeSelect.value,
                minimalPairType: minimalPairTypeSelect.value,
                includedCategories: includedCategories,
                minimalPairDifferType: minimalPairDifferTypeCheckbox.checked,
            }));


            document.getElementById("chosen-settings").classList.remove("hidden");

            homophoneHeading.style.marginTop = "-20px";

            homophoneHeading.classList.remove("hidden");
            minimalPairHeading.classList.remove("hidden");

            // Pass the excluded categories to allWords
            const allWords = dict.allWords(defaultExcludedCategories);

            const words = allWords.filter(word => includedCategories.includes(word.category));

            dropdownWrapper.remove();
            
            await findPairs(words);
        });
    })

</script>