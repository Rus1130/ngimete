<style>
    ol {
        margin-top: 0;
    }

    input[type="checkbox"]:focus, #input:focus, button:focus {
        outline: none;
    }

    
    .hidden {
        display: none;
    }

    button {
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        padding: 3px 8px;
        cursor: pointer;
        font-size: 14px;
        margin: 10px 0;
    }

    .dropdown {
        position: relative;
        display: inline-block;
        font-size: 12px;
    }

    /* Dropdown content */
    .dropdown-content {
        display: none;
        position: absolute;
        background-color: white;
        min-width: 200px;
        max-height: 150px;
        overflow-y: auto;
        border: 1px solid #ccc;
        z-index: 1;
        padding: 5px;
    }

    /* Show dropdown on button click */
    .dropdown.show .dropdown-content {
        display: block;
        user-select: none;
    }

    /* Style checkboxes */
    .dropdown-content input[type="checkbox"] {
        margin-right: 4px;
        transform: scale(0.85);
    }
</style>
<head>
    <meta property="og:title" content="ngimëte Similarities">
    <meta property="og:description" content="Find homophones and minimal pairs">
    <meta property="og:url" content="https://rus1130.github.io/projects/ngimete/similarities">
</head>
<body>
    <div id="loading" class="hidden"></div>
    <div id="dropdown-wrapper" style="display: inline-block;">
        <label for="exclude-categories-dropdown">Include Categories:</label>
        <div id="exclude-categories-dropdown" class="dropdown">
            <button type="button" class="dropbtn" id="exclude-categories-button">Select Categories ▼</button>
            <div class="dropdown-content" id="exclude-categories">
            </div>
        </div>
    </div>
    <button id="begin">Begin</button>
    <h1>Homophones:</h1>
    <div id="homophone-results"></div>
    <h1>Minimal Pairs:</h1>
    <div id="minimal-pair-results"></div>
</body>
<script type="module" defer>
    import { dict } from './dictionary.js';

    const loadingDiv = document.getElementById("loading");
    const homophoneResults = document.getElementById("homophone-results");
    const minimalPairResults = document.getElementById("minimal-pair-results");
    const beginButton = document.getElementById("begin");
    const dropdownWrapper = document.getElementById("dropdown-wrapper");

    // Keep track of rendered divs by key
    const homophoneDivs = new Map();
    const minimalPairDivs = new Map();

    function isHomophone(word1, word2, dialect){
        return word1.value[dialect] === word2.value[dialect];
    }

    function isNearHomophone(word1, word2, dialect){
        const val1 = word1.value[dialect];
        const val2 = word2.value[dialect];

        if(Math.abs(val1.length - val2.length) > 1){
            return false;
        }

        let differences = 0;
        let i = 0;
        let j = 0;

        while(i < val1.length && j < val2.length){
            if(val1[i] !== val2[j]){
                differences++;
                if(differences > 1){
                    return false;
                }

                if(val1.length > val2.length){
                    i++;
                } else if(val1.length < val2.length){
                    j++;
                } else {
                    i++;
                    j++;
                }
            } else {
                i++;
                j++;
            }
        }

        return true;
    }


    const dialect = "A'atsilwi";

    function addOrUpdateHomophoneSet(key, set){
        // Check if div already exists
        if(homophoneDivs.has(key)){
            // Update existing div
            const div = homophoneDivs.get(key);
            const ol = div.querySelector("ol");
            
            // Clear and repopulate the list
            ol.innerHTML = "";
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });
        } else {
            // Create new div
            const div = document.createElement("div");

            const keySpan = document.createElement("span");
            keySpan.style.fontWeight = "bold";
            keySpan.textContent = key;
            div.appendChild(keySpan);

            const ol = document.createElement("ol");
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });

            div.appendChild(ol);
            homophoneResults.appendChild(div);
            
            // Store reference to the div
            homophoneDivs.set(key, div);
        }
    }

    function addOrUpdateMinimalPairSet(key, set){
        // Check if div already exists
        if(minimalPairDivs.has(key)){
            // Update existing div
            const div = minimalPairDivs.get(key);
            const ol = div.querySelector("ol");
            
            // Clear and repopulate the list
            ol.innerHTML = "";
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });
        } else {
            // Create new div
            const div = document.createElement("div");

            const keySpan = document.createElement("span");
            keySpan.style.fontWeight = "bold";
            keySpan.textContent = key;
            div.appendChild(keySpan);

            const ol = document.createElement("ol");
            set.forEach((wordKey) => {
                const li = document.createElement("li");
                li.textContent = wordKey;
                ol.appendChild(li);
            });

            div.appendChild(ol);
            minimalPairResults.appendChild(div);
            
            // Store reference to the div
            minimalPairDivs.set(key, div);
        }
    }


    async function findPairs(words) {
        const homophones = new Map();
        const nearHomophones = new Map();

        const resultsContainer = document.getElementById("results");
        const chunkSize = 200; // number of comparisons per chunk

        const totalComparisons = (words.length * (words.length - 1)) / 2;
        let comparisonsDone = 0;
        let outerComparisonsDone = 0;

        for (let i = 0; i < words.length; i++) {
            for (let j = i + 1; j < words.length; j++) {

                // --- DO YOUR CHECK HERE ---
                const w1 = words[i];
                const w2 = words[j];

                if (isHomophone(w1, w2, dialect)) {
                    const key = w1.value[dialect];

                    if(key.trim() === "") continue;

                    if (!homophones.has(key)) {
                        homophones.set(key, new Set());
                    }

                    homophones.get(key).add(w1.key);
                    homophones.get(key).add(w2.key);

                    // Update the rendered div with the current set
                    addOrUpdateHomophoneSet(key, homophones.get(key));
                }

                if (isNearHomophone(w1, w2, dialect)) {
                    const key = `${w1.value[dialect]} ~ ${w2.value[dialect]}`;

                    if (!nearHomophones.has(key)) {
                        nearHomophones.set(key, new Set());
                    }

                    nearHomophones.get(key).add(w1.key);
                    nearHomophones.get(key).add(w2.key);

                    // Update the rendered div with the current set
                    addOrUpdateMinimalPairSet(key, nearHomophones.get(key));
                }

                loadingDiv.textContent =
                        `Progress: ${((comparisonsDone / totalComparisons) * 100).toFixed(2)}%`;

                // // Yield control every N iterations
                if ((j % chunkSize) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                comparisonsDone++;
            }
            outerComparisonsDone++;
        }

        loadingDiv.textContent = `Completed! Found ${homophones.size} homophone sets. Total comparisons: ${totalComparisons}. Reload the page to run again.`;
    }

    dict.waitForDictLoad().then(async () => {
        async function generateCategoryCheckboxes() {
            const container = document.getElementById("exclude-categories");
            container.innerHTML = "";

            const categories = dict.practiceOrder

            categories.forEach(category => {
                if(!defaultExcludedCategories.includes(category)) {
                    const id = `exclude-${category.replace(/\s+/g, "-")}`;

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.name = "exclude-category";
                    checkbox.value = category;
                    checkbox.id = id;
                    checkbox.checked = true;

                    const label = document.createElement("label");
                    label.htmlFor = id;
                    label.textContent = category;

                    const wrapper = document.createElement("div");
                    wrapper.appendChild(checkbox);
                    wrapper.appendChild(label);

                    container.appendChild(wrapper);

                    // Shift+Click behavior: check all other checkboxes
                    checkbox.addEventListener("click", (e) => {
                        // get how many checkboxes are checked
                        updateCheckedBoxText();

                        if (e.shiftKey) {
                            const allCheckboxes = container.querySelectorAll('input[name="exclude-category"]');
                            allCheckboxes.forEach(cb => {
                                if (cb !== checkbox) cb.checked = false;
                            });
                            e.target.checked = true;
                            updateCheckedBoxText();
                        }
                    });
                }
            });
        }

        function updateCheckedBoxText(){
            const container = document.getElementById("exclude-categories");
            const checkedBoxes = container.querySelectorAll('input[name="exclude-category"]:checked').length;

            if(checkedBoxes === 0) excludeCategoriesButton.innerText = "Select Categories ▼";
            else excludeCategoriesButton.innerText = `${checkedBoxes} Categor${checkedBoxes == 1 ? "y" : "ies"} Included ▼`;
        }

        function getIncludedCategories() {
            const categories = [];

            // Included categories from URL
            if (excludedCategoriesParam) {
                categories.push(...excludedCategoriesParam.split("$"));
            }

            // Included categories from nav checkboxes
            const checkedBoxes = document.querySelectorAll('input[name="exclude-category"]:checked');
            checkedBoxes.forEach(cb => categories.push(cb.value));

            return categories;
        }

        
        const dropdown = document.getElementById("exclude-categories-button");

        const excludeCategoriesButton = document.getElementById("exclude-categories-button");
        const defaultExcludedCategories = ["Consonant Sounds", "Vowel Sounds", "Connecting Letters", "Tenses", "Phrases", "Grammar"];
        const urlParams = new URLSearchParams(window.location.search);
        const excludedCategoriesParam = urlParams.get("excludeCategories");

        const container = document.getElementById("exclude-categories-dropdown");

        await generateCategoryCheckboxes();
        updateCheckedBoxText();

        dropdown.addEventListener("click", () => {
            container.classList.toggle("show");
        });

        window.addEventListener("click", (e) => {
            if (!container.contains(e.target)) {
                container.classList.remove("show");
            }
        });


        beginButton.addEventListener("click", async () => {
            beginButton.remove();
            loadingDiv.classList.remove("hidden");


            // get the included categories
            const includedCategories = structuredClone(getIncludedCategories());

            // Pass the excluded categories to allWords
            const allWords = dict.allWords(defaultExcludedCategories);

            const words = allWords.filter(word => includedCategories.includes(word.category));

            console.log("Total words:", words.length);

            dropdownWrapper.remove();
            
            await findPairs(words);
        });
    })

</script>