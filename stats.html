<style>
    div {
        display: inline-block;
        border: 1px solid black;
    }
    .bar {
        height: 500px;
        width: 1200px;
    }

    .pie {
        height: 500px;
        width: 500px;
    }
</style>
<head>
    <meta property="og:title" content="ngimëte Statistics">
    <meta property="og:description" content="Letter and category statistics for the ngimëte language.">
    <meta property="og:url" content="https://rus1130.github.io/projects/ngimete/stats">
    <meta name="google" content="notranslate">
</head>
<body>
    <div class="bar" id="standard-letter-distrib"></div><br>
    <div class="bar" id="aatsilwi-letter-distrib"></div>
    <div class="pie" id="categories"></div>
</body>
<script type="module">
    import { dict } from './dictionary.js';
    import { PieChart, BarChart } from 'https://rus1130.github.io/projects/another-chart-library/main.js';

    const distributionStandard = {};
    const distributionAatsilwi = {};
    const categoriesDistribution = {};

    const onsetsStandard = new Map();
    const codasStandard = new Map();

    const onsetsAatsilwi = new Map();
    const codasAatsilwi = new Map();


    const IPA_VOWEL_BASE = /[aeiouɑəy]/i;
    const IPA_DIACRITICS = /[\u032F\u0300-\u036F]/;

    function isVowel(token) {
        return IPA_VOWEL_BASE.test(token[0]);
    }

    function tokenizeIPA(s) {
        const tokens = [];
        const chars = [...s]; // spreads by Unicode codepoint

        for (let i = 0; i < chars.length; i++) {
            const c = chars[i];

            // vowel nucleus
            if (IPA_VOWEL_BASE.test(c)) {
                let token = c;

                // attach combining diacritics (̯, ̃, etc.)
                while (i + 1 < chars.length && IPA_DIACRITICS.test(chars[i + 1])) {
                    token += chars[++i];
                }

                // attach length marker
                if (chars[i + 1] === "ː") {
                    token += chars[++i];
                }

                tokens.push(token);
                continue;
            }

            tokens.push(c);
        }

        return tokens;
    }

    function extractOnset(syllable) {
        const tokens = tokenizeIPA(syllable);
        const i = tokens.findIndex(isVowel);
        return i > 0 ? tokens.slice(0, i).join("") : "";
    }

    function extractCoda(syllable) {
        const tokens = tokenizeIPA(syllable);
        let lastVowel = -1;

        tokens.forEach((t, i) => {
            if (isVowel(t)) lastVowel = i;
        });

        return lastVowel !== -1 && lastVowel < tokens.length - 1
            ? tokens.slice(lastVowel + 1).join("")
            : "";
    }

    function getSyllables(conlangContent){
        return conlangContent.toString(undefined, undefined, ["ipa"]).replaceAll(/\[|\]/g, "").split(".")
    }

    function addToMap(map, key, source) {
    if (!map.has(key)) {
            map.set(key, {
                count: 1,
                sources: new Set([source])
            });
        } else {
            const entry = map.get(key);
            entry.count++;
            entry.sources.add(source);
        }
    }

    dict.waitForDictLoad().then(() => {
        dict.practiceOrder.forEach((set) => {
            if(!["dont add", "Phrases", "Grammar", "Vowel Sounds", "Consonant Sounds", "Connecting Letters"].includes(set)){
                dict.dict[set].forEach((word) => {

                const standardSyllables = getSyllables(word.script["Standard"]);

                standardSyllables.forEach((syllable) => {
                    if (!syllable) return;

                    const onset = extractOnset(syllable);
                    const coda  = extractCoda(syllable);

                    if (onset) {
                        console.log()
                        addToMap(onsetsStandard, onset, `[${syllable}] in ${word.script["Standard"].toString(undefined, undefined , ["ipa"])}`);
                    }

                    if (coda) {
                        addToMap(codasStandard, coda, word.script["Standard"].toString(undefined, undefined , ["ipa"]));
                    }
                });

                    if(categoriesDistribution[set]) categoriesDistribution[set]++;
                    else categoriesDistribution[set] = 1;
                    
                    let def = word.value["Standard"];
                    def.split("").forEach((letter) => {
                        if(distributionStandard[letter]){
                            distributionStandard[letter]++;
                        } else {
                            distributionStandard[letter] = 1;
                        }
                    })

                    def = word.value["A'atsilwi"];
                    def.split("").forEach((letter, i) => {
                        // if its a capital letter or symbol, do not count
                        if(/[A-Z<>()]/.test(letter)) return;
                        if(distributionAatsilwi[letter]){
                            distributionAatsilwi[letter]++;
                        } else {
                            distributionAatsilwi[letter] = 1;
                        }
                    })
                })
            }
        })

        let standardKeys = Object.keys(distributionStandard);
        let standardValues = Object.values(distributionStandard);

        let aatsilwiKeys = Object.keys(distributionAatsilwi);
        let aatsilwiValues = Object.values(distributionAatsilwi);

        // short standardKeys and standardValues from greatest to least
        for(let i = 0; i < standardKeys.length; i++){
            for(let j = i + 1; j < standardKeys.length; j++){
                if(standardValues[i] < standardValues[j]){
                    let temp = standardValues[i];
                    standardValues[i] = standardValues[j];
                    standardValues[j] = temp;

                    temp = standardKeys[i];
                    standardKeys[i] = standardKeys[j];
                    standardKeys[j] = temp;
                }
            }
        }

        // short aatsilwiKeys and aatsilwiValues from greatest to least
        for(let i = 0; i < aatsilwiKeys.length; i++){
            for(let j = i + 1; j < aatsilwiKeys.length; j++){
                if(aatsilwiValues[i] < aatsilwiValues[j]){
                    let temp = aatsilwiValues[i];
                    aatsilwiValues[i] = aatsilwiValues[j];
                    aatsilwiValues[j] = temp;

                    temp = aatsilwiKeys[i];
                    aatsilwiKeys[i] = aatsilwiKeys[j];
                    aatsilwiKeys[j] = temp;
                }
            }
        }

        console.log(onsetsStandard)
        console.log(codasStandard)

        new BarChart(`#standard-letter-distrib`,{width:1200,height:500})
        .setData("Standard Dialect Letter Distribution","Letter","Frequency",100,4,standardKeys, standardValues);

        new BarChart("#aatsilwi-letter-distrib", {width:1200, height:500})
        .setData("A'atsilwi Dialect Letter Distribution","Letter","Frequency",100,4,aatsilwiKeys, aatsilwiValues);

        let pieChart = new PieChart("#categories", {
            width: 500,
            height: 500
        }).setData("Categories", PieChart.objectToPieData(categoriesDistribution), {
            popAmount: 4,
            showPercentages: true,
            donut: true,
            sliceOutlineWidth: 1,
            sliceOutlineColor: 'white',
            //showLabelsOnHover: true
        })
    });
</script>